# Octave语法
* 一个语句后面加上 ";"就会抑制输出，不会在最终的控制台上显示
* 不等于的判断是 ~= 而不是 !=；等于的判断依然是 ==
* pi可以直接使用，被定义为:3.1416
* disp(a)这个函数来显示一个变量的内容
* 可以使用c语言配合使用 disp(sprintf('2 decials: %0.2f', a)
* 矩阵的输入方法：A = [1 2; 3 4; 5 6]
* v = 1:0.1:2 这是通过循环的方法来产生行向量 1.0000    1.1000    1.2000    1.3000    1.4000    1.5000    1.6000    1.7000    1.8000    1.9000    2.0000. 唯一需要注意的地方是 对于2来说是闭区间，而对于正常的循环来说是开区间
* ones(2,3) 表示是2*3的矩阵 都是1
* zeros(1,3) 表示的是1*3的矩阵 都是0
* rand(1,3) 是用随机数来填充的1*3矩阵
* randn：产生均值为0方差为1、幅度在0~1之间、的高斯白噪声（即正太分布）
* eye(4) 产生的是单位矩阵
* help eye 输出帮助
* 对于一个矩阵来说 size(A)返回是 1*2向量 分别是 行和列的数量
* length(A)返回的是最大长度
* load可以载入所有数据
* who 能看到所有变量 whos能够看得到更多细节
* clear featuresX 清除一个变量
* save hello.mat 保存数据
* save hello.txt v -ascii
* A(3,2)索引第3行2列 然而 A(:,2)索引所有第2列
* A = [A, [100; 101; 102]] 可以这样直接增加矩阵的列
* 矩阵的组合 C = [A B] 和 C = [A; B]
* A*B表示矩阵的相乘
* .操作符表示的是对每一个元素都这样。例如A .* B 表示A中每一个元素都和B中每一个元素相乘。A .^2 表示对每一个元素平方。
* : 冒号表达式 begin:步长:end 1:2:7 -> 1, 3, 5, 7;begin:end = begin:1:end
* 求余数的方法是 rem
* 矩阵每一个元素都加1，是 X + 1即可。也可以  X .+1

## plot
plot(x, y) 是默认的将所有的点连在一起。所以如果想划出离散的点, plot(x, y, 'rx') 最后一个参数表示 红色, x表示线条的形式，是个“叉”，这样就不会连接在一起了。

## 矩阵基本操作

	% 测试矩阵的性质
	% 1 矩阵中每一个元素都加1
	fprintf("1 矩阵中每一个元素都加1\n");
	X = eye(3)
	X = X+1

	% 2 矩阵中每一个元素都求对数
	fprintf("2 矩阵中每一个元素都求对数\n");
	X = [1 10; 100 1000]
	X = log10(X)

	% 3 矩阵中每一个元素都求指数
	fprintf("3 矩阵中每一个元素都求指数\n");
	X = [1 log(2); log(3) log(4)]
	X = exp(X)

	% 4 矩阵中每一个元素求倒数
	fprintf("4 矩阵中每一个元素求倒数\n");
	X = [1 5; 10 20]
	X = 1./X
	
	% 7 测试逻辑运算 对每一个元素都执行同样的逻辑
	fprintf("test <= 0.5 \n")
	X = eye(3)
	X = X <= 0.5
	
## bxsfun函数
这个函数非常方便，因为可以对矩阵进行子矩阵的运算。例如，将矩阵A（3，2）=[1 2; 4 5; 7 8] 每一行分别乘以1， 2 ，3和每一行分别乘以1, 2 ,3就可以这样处理。

	X = [1 2; 3 4; 5 6]
	fprintf("times for every row\n");
	a = [1; 2; 3]
	A = bsxfun(@times, X, a)

	fprintf("times for every column\n");
	b = [1 2]
	B = bsxfun(@times, X, b) 
	
## 根据逻辑向量获取矩阵中的数值

	X = [1 2 3; 4 5 6]
	
	R = logical([1   1   0  ; 1   0   0])
	
	RL = [true true false; true false false]
	
	Result = X(1, R(1, :))
	
	ResultL = X(1, RL(1, :))
	
R中为1的位置，对应到X的位置的元素被得到。